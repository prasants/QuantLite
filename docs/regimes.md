# Regime Detection

Markets do not behave the same way all the time. Periods of calm, trending markets alternate with volatile, crisis-driven episodes. QuantLite provides three complementary approaches to identifying these structural shifts.

### HMM Regime Timeline

A three-regime HMM identifies bull (green), transitional (teal), and crisis (red) periods. The annualised volatility differs markedly across regimes:

![Regime Timeline](images/regime_timeline.png)

### Transition Probability Matrix

The transition matrix shows regime persistence (high diagonal values) and the probability of switching between states:

![Transition Matrix](images/transition_matrix.png)

### Regime-Conditional Distributions

Return distributions plotted separately for each regime reveal dramatically different risk profiles. The crisis regime has a wider, left-shifted distribution:

![Regime Distributions](images/regime_distributions.png)

### Bayesian Changepoint Detection

Bayesian online changepoint detection identifies structural breaks without requiring a fixed number of regimes. The confidence bars indicate detection certainty:

![Changepoint Detection](images/changepoint_detection.png)

## Hidden Markov Models (`quantlite.regimes.hmm`)

Gaussian HMMs model the return series as being generated by a hidden discrete state (the "regime") that switches according to a Markov chain. Each regime has its own mean and variance.

**Requires `hmmlearn`:** `pip install hmmlearn`

### Fitting a Regime Model

```python
from quantlite.regimes.hmm import fit_regime_model, select_n_regimes, regime_probabilities
from quantlite.distributions.fat_tails import student_t_process

returns = student_t_process(nu=4, mu=0.0003, sigma=0.015, n_steps=2520, rng_seed=42)

# Fit a 2-state model
model = fit_regime_model(returns, n_regimes=2, rng_seed=42)

print(f"Regime means:     {model.means}")
print(f"Regime variances: {model.variances}")
print(f"Stationary dist:  {model.stationary_distribution}")
print(f"AIC: {model.aic:.1f}, BIC: {model.bic:.1f}")

# Transition matrix
print("Transition matrix:")
print(model.transition_matrix)
```

Regimes are sorted by mean (lowest mean = regime 0, typically the crisis regime). This ensures consistent labelling across fits.

### Model Selection

```python
# Automatically select the number of regimes (2 to 4) by BIC
best_model = select_n_regimes(returns, max_regimes=4, rng_seed=42)
print(f"Best: {best_model.n_regimes} regimes (BIC={best_model.bic:.1f})")
```

### Regime Probabilities

The forward-backward algorithm provides posterior probabilities for each regime at each time step, which are smoother than the Viterbi-decoded labels:

```python
probs = regime_probabilities(model, returns)
print(f"Shape: {probs.shape}")  # (n_obs, n_regimes)
# probs[t, k] = P(regime_t = k | all observations)
```

## Changepoint Detection (`quantlite.regimes.changepoint`)

Unlike HMM (which assumes recurring regimes), changepoint detection identifies one-off structural breaks where the statistical properties of the series change permanently.

### CUSUM Detection

The CUSUM (Cumulative Sum) algorithm tracks standardised cumulative deviations from the mean, flagging a changepoint when the cumulative sum exceeds a penalty threshold:

```python
from quantlite.regimes.changepoint import detect_changepoints
import numpy as np

# Create returns with an embedded structural break
rng = np.random.default_rng(42)
pre_break = rng.normal(0.001, 0.01, 500)
post_break = rng.normal(-0.001, 0.02, 500)
returns = np.concatenate([pre_break, post_break])

# CUSUM detection
cps = detect_changepoints(returns, method="cusum", penalty=5.0)
for cp in cps:
    print(f"Index {cp.index}: confidence={cp.confidence:.2f}, direction={cp.direction}")
```

Higher penalty values produce fewer, more confident detections.

### Bayesian Online Changepoint Detection

Implements the Adams and MacKay (2007) algorithm with a normal-inverse-gamma conjugate prior. This method provides probabilistic detection and works in an online (streaming) fashion:

```python
cps = detect_changepoints(returns, method="bayesian", penalty=50.0)
for cp in cps:
    print(f"Index {cp.index}: confidence={cp.confidence:.2f}, direction={cp.direction}")
```

The penalty parameter controls the hazard rate (1/penalty = prior probability of a changepoint at each step). Higher values mean fewer expected changepoints.

### Working with DatetimeIndex

If the input is a pandas Series with a DatetimeIndex, each `ChangePoint` includes the corresponding date:

```python
import pandas as pd

dates = pd.bdate_range("2020-01-01", periods=1000)
returns_series = pd.Series(returns, index=dates)
cps = detect_changepoints(returns_series, method="cusum")
for cp in cps:
    print(f"{cp.date}: {cp.direction} (confidence {cp.confidence:.2f})")
```

## Conditional Risk Metrics (`quantlite.regimes.conditional`)

Once regimes are identified, risk metrics can be computed separately for each regime, revealing how the risk profile changes across market states.

### Per-Regime Metrics

```python
from quantlite.regimes.conditional import conditional_metrics
from quantlite.regimes.hmm import fit_regime_model

model = fit_regime_model(returns, n_regimes=2, rng_seed=42)
cond = conditional_metrics(returns, model.regime_labels)

for regime, metrics in cond.items():
    print(f"\nRegime {regime}:")
    for key, val in metrics.items():
        print(f"  {key}: {val:.6f}")
```

### Regime Transition Risk

Quantify the probability and expected timing of transitioning from calm to crisis:

```python
from quantlite.regimes.conditional import regime_transition_risk

risk = regime_transition_risk(model)
print(f"P(calm -> crisis): {risk['calm_to_crisis_prob']:.4f}")
print(f"Expected duration in each regime:")
for regime, dur in risk['expected_durations'].items():
    print(f"  Regime {regime}: {dur:.1f} periods")
```

### Conditional Correlation

Correlation matrices computed separately per regime often reveal that assets become more correlated during crises:

```python
from quantlite.regimes.conditional import conditional_correlation
import pandas as pd
import numpy as np

rng = np.random.default_rng(42)
returns_df = pd.DataFrame({
    "Equities": rng.normal(0.0003, 0.012, len(returns)),
    "Bonds": rng.normal(0.0001, 0.005, len(returns)),
})

corr_by_regime = conditional_correlation(returns_df, model.regime_labels)
for regime, corr_matrix in corr_by_regime.items():
    print(f"\nRegime {regime} correlation:")
    print(corr_matrix)
```

### Regime-Aware VaR

VaR weighted by current regime probabilities, rather than unconditional VaR which blends calm and crisis periods:

```python
from quantlite.regimes.conditional import regime_aware_var

# Using empirical regime frequencies
rvar = regime_aware_var(returns, model.regime_labels, alpha=0.05)
print(f"Regime-aware VaR (95%): {rvar:.4f}")

# Using specific regime probabilities (e.g., if you believe crisis is likely)
import numpy as np
crisis_probs = np.array([0.7, 0.3])  # 70% weight on crisis regime
rvar_stressed = regime_aware_var(returns, model.regime_labels, alpha=0.05, current_probs=crisis_probs)
print(f"Stressed regime VaR:    {rvar_stressed:.4f}")
```

## Combining Approaches

The three methods complement each other:

1. **HMM** identifies recurring regimes (e.g., calm vs. volatile vs. crisis) and provides transition probabilities
2. **Changepoint detection** identifies permanent structural breaks (e.g., a policy change)
3. **Conditional metrics** quantify the risk in each identified state

A typical workflow:

```python
from quantlite.regimes.hmm import fit_regime_model
from quantlite.regimes.changepoint import detect_changepoints
from quantlite.regimes.conditional import conditional_metrics, regime_transition_risk

# 1. Detect regimes
model = fit_regime_model(returns, n_regimes=2, rng_seed=42)

# 2. Find structural breaks within those regimes
cps = detect_changepoints(returns, method="bayesian", penalty=50)

# 3. Compute per-regime risk
cond = conditional_metrics(returns, model.regime_labels)
trans_risk = regime_transition_risk(model)

# 4. Use for allocation decisions
crisis_prob = model.stationary_distribution[0]
print(f"Long-run probability of being in crisis: {crisis_prob:.2%}")
```
